/*
 * generated by Xtext 2.21.0
 */
package org.eclipse.acme.serializer;

import cnl.AfterDateExpression;
import cnl.AndExpression;
import cnl.ArithmeticExpression;
import cnl.BeforeDateExpression;
import cnl.BooleanValue;
import cnl.CNLRule;
import cnl.CnlPackage;
import cnl.ConstrainedNaturalLanguageRules;
import cnl.DateValue;
import cnl.DecimalValue;
import cnl.EOLExpressionRule;
import cnl.ElementScope;
import cnl.EmptyValue;
import cnl.EnumTypeExpression;
import cnl.EnumValue;
import cnl.Enumerations;
import cnl.EqualityExpression;
import cnl.ExistanceValue;
import cnl.Feature;
import cnl.FeatureValue;
import cnl.GTEExpression;
import cnl.GreaterThanExpression;
import cnl.IfandonlyifExpression;
import cnl.ImpliesExpression;
import cnl.IntegerValue;
import cnl.LTEExpression;
import cnl.LessThanExpression;
import cnl.MatchScopedRule;
import cnl.MatchingRule;
import cnl.NegatedEqualityExpression;
import cnl.NumericAverage;
import cnl.NumericMaximum;
import cnl.NumericMinimum;
import cnl.NumericSummation;
import cnl.OnorafterDateExpression;
import cnl.OnorbeforeDateExpression;
import cnl.OrExpression;
import cnl.PrimitiveTypeExpression;
import cnl.ScopedRules;
import cnl.StringValue;
import cnl.Type;
import cnl.Types;
import cnl.UniquenessCheck;
import cnl.ValueContainment;
import cnl.XorExpression;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.acme.services.ACMECNlGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ACMECNlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ACMECNlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CnlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CnlPackage.AFTER_DATE_EXPRESSION:
				sequence_DateExpression(context, (AfterDateExpression) semanticObject); 
				return; 
			case CnlPackage.AND_EXPRESSION:
				sequence_LogicalExpression(context, (AndExpression) semanticObject); 
				return; 
			case CnlPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case CnlPackage.BEFORE_DATE_EXPRESSION:
				sequence_DateExpression(context, (BeforeDateExpression) semanticObject); 
				return; 
			case CnlPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case CnlPackage.CNL_RULE:
				sequence_CNLRule(context, (CNLRule) semanticObject); 
				return; 
			case CnlPackage.CONSTRAINED_NATURAL_LANGUAGE_RULES:
				sequence_ConstrainedNaturalLanguageRules(context, (ConstrainedNaturalLanguageRules) semanticObject); 
				return; 
			case CnlPackage.DATE_VALUE:
				sequence_DateValue(context, (DateValue) semanticObject); 
				return; 
			case CnlPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case CnlPackage.EOL_EXPRESSION_RULE:
				sequence_EOLExpressionRule(context, (EOLExpressionRule) semanticObject); 
				return; 
			case CnlPackage.ELEMENT_SCOPE:
				sequence_ElementScope(context, (ElementScope) semanticObject); 
				return; 
			case CnlPackage.EMPTY_VALUE:
				sequence_EmptyValue(context, (EmptyValue) semanticObject); 
				return; 
			case CnlPackage.ENUM:
				sequence_Enum(context, (cnl.Enum) semanticObject); 
				return; 
			case CnlPackage.ENUM_TYPE_EXPRESSION:
				sequence_EnumTypeExpression(context, (EnumTypeExpression) semanticObject); 
				return; 
			case CnlPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case CnlPackage.ENUMERATIONS:
				sequence_Enumerations(context, (Enumerations) semanticObject); 
				return; 
			case CnlPackage.EQUALITY_EXPRESSION:
				sequence_ComparisonExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case CnlPackage.EXISTANCE_VALUE:
				sequence_ExistanceValue(context, (ExistanceValue) semanticObject); 
				return; 
			case CnlPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case CnlPackage.FEATURE_VALUE:
				if (rule == grammarAccess.getFeatureValueRule()) {
					sequence_FeatureValue(context, (FeatureValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalExpressionRule()
						|| action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionLhsAction_0_1_0_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionRhsAction_0_1_1_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getOrExpressionLhsAction_0_1_2_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getXorExpressionLhsAction_0_1_3_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getAndExpressionLhsAction_0_1_4_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getIfandonlyifExpressionLhsAction_0_1_5_0()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getEqualityExpressionLhsAction_1_1_0_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getNegatedEqualityExpressionLhsAction_1_1_1_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getEqualityExpressionLhsAction_1_1_2_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getNegatedEqualityExpressionLhsAction_1_1_3_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getGreaterThanExpressionLhsAction_1_1_4_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getLessThanExpressionLhsAction_1_1_5_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getGTEExpressionLhsAction_1_1_6_0()
						|| action == grammarAccess.getComparisonExpressionAccess().getLTEExpressionLhsAction_1_1_7_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLhsAction_1_0()
						|| rule == grammarAccess.getBaseExpressionRule()) {
					sequence_FeatureValue_UnscopedFeatureValue_VariableFeatureValue(context, (FeatureValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnscopedFeatureValueRule()) {
					sequence_UnscopedFeatureValue(context, (FeatureValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableFeatureValueRule()) {
					sequence_VariableFeatureValue(context, (FeatureValue) semanticObject); 
					return; 
				}
				else break;
			case CnlPackage.GTE_EXPRESSION:
				sequence_ComparisonExpression(context, (GTEExpression) semanticObject); 
				return; 
			case CnlPackage.GREATER_THAN_EXPRESSION:
				sequence_ComparisonExpression(context, (GreaterThanExpression) semanticObject); 
				return; 
			case CnlPackage.IFANDONLYIF_EXPRESSION:
				sequence_LogicalExpression(context, (IfandonlyifExpression) semanticObject); 
				return; 
			case CnlPackage.IMPLIES_EXPRESSION:
				if (action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionLhsAction_0_1_0_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionRhsAction_0_1_1_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getOrExpressionLhsAction_0_1_2_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getXorExpressionLhsAction_0_1_3_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getAndExpressionLhsAction_0_1_4_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getIfandonlyifExpressionLhsAction_0_1_5_0()) {
					sequence_LogicalExpression_AndExpression_0_1_4_0_IfandonlyifExpression_0_1_5_0_ImpliesExpression_0_1_0_0_ImpliesExpression_0_1_1_0_OrExpression_0_1_2_0_XorExpression_0_1_3_0(context, (ImpliesExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalExpressionRule()) {
					sequence_LogicalExpression(context, (ImpliesExpression) semanticObject); 
					return; 
				}
				else break;
			case CnlPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case CnlPackage.LTE_EXPRESSION:
				sequence_ComparisonExpression(context, (LTEExpression) semanticObject); 
				return; 
			case CnlPackage.LESS_THAN_EXPRESSION:
				sequence_ComparisonExpression(context, (LessThanExpression) semanticObject); 
				return; 
			case CnlPackage.MATCH_SCOPED_RULE:
				sequence_MatchScopedRule(context, (MatchScopedRule) semanticObject); 
				return; 
			case CnlPackage.MATCHING_RULE:
				sequence_MatchingRule(context, (MatchingRule) semanticObject); 
				return; 
			case CnlPackage.NEGATED_EQUALITY_EXPRESSION:
				sequence_ComparisonExpression(context, (NegatedEqualityExpression) semanticObject); 
				return; 
			case CnlPackage.NUMERIC_AVERAGE:
				sequence_NumericAverage(context, (NumericAverage) semanticObject); 
				return; 
			case CnlPackage.NUMERIC_MAXIMUM:
				sequence_NumericMaximum(context, (NumericMaximum) semanticObject); 
				return; 
			case CnlPackage.NUMERIC_MINIMUM:
				sequence_NumericMinimum(context, (NumericMinimum) semanticObject); 
				return; 
			case CnlPackage.NUMERIC_SUMMATION:
				sequence_NumericSummation(context, (NumericSummation) semanticObject); 
				return; 
			case CnlPackage.ONORAFTER_DATE_EXPRESSION:
				sequence_DateExpression(context, (OnorafterDateExpression) semanticObject); 
				return; 
			case CnlPackage.ONORBEFORE_DATE_EXPRESSION:
				sequence_DateExpression(context, (OnorbeforeDateExpression) semanticObject); 
				return; 
			case CnlPackage.OR_EXPRESSION:
				sequence_LogicalExpression(context, (OrExpression) semanticObject); 
				return; 
			case CnlPackage.PRIMITIVE_TYPE_EXPRESSION:
				sequence_PrimitiveTypeExpression(context, (PrimitiveTypeExpression) semanticObject); 
				return; 
			case CnlPackage.SCOPED_RULES:
				sequence_ScopedRules(context, (ScopedRules) semanticObject); 
				return; 
			case CnlPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case CnlPackage.TYPE:
				sequence_TypeValue(context, (Type) semanticObject); 
				return; 
			case CnlPackage.TYPES:
				sequence_Types(context, (Types) semanticObject); 
				return; 
			case CnlPackage.UNIQUENESS_CHECK:
				sequence_UniquenessCheck(context, (UniquenessCheck) semanticObject); 
				return; 
			case CnlPackage.VALUE_CONTAINMENT:
				sequence_ValueContainment(context, (ValueContainment) semanticObject); 
				return; 
			case CnlPackage.XOR_EXPRESSION:
				if (action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionLhsAction_0_1_0_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getImpliesExpressionRhsAction_0_1_1_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getOrExpressionLhsAction_0_1_2_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getXorExpressionLhsAction_0_1_3_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getAndExpressionLhsAction_0_1_4_0()
						|| action == grammarAccess.getLogicalExpressionAccess().getIfandonlyifExpressionLhsAction_0_1_5_0()) {
					sequence_LogicalExpression_AndExpression_0_1_4_0_IfandonlyifExpression_0_1_5_0_ImpliesExpression_0_1_0_0_ImpliesExpression_0_1_1_0_OrExpression_0_1_2_0_XorExpression_0_1_3_0(context, (XorExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalExpressionRule()) {
					sequence_LogicalExpression(context, (XorExpression) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     LogicalExpression returns ArithmeticExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns ArithmeticExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns ArithmeticExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns ArithmeticExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns ArithmeticExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns ArithmeticExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns ArithmeticExpression
	 *     ComparisonExpression returns ArithmeticExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns ArithmeticExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns ArithmeticExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns ArithmeticExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns ArithmeticExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns ArithmeticExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns ArithmeticExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns ArithmeticExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (lhs=ArithmeticExpression_ArithmeticExpression_1_0 type=ArithmeticOperations rhs=BaseExpression)
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.ARITHMETIC_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getTypeArithmeticOperationsEnumRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getRhsBaseExpressionParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns BooleanValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns BooleanValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns BooleanValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns BooleanValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns BooleanValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns BooleanValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns BooleanValue
	 *     ComparisonExpression returns BooleanValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns BooleanValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns BooleanValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns BooleanValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns BooleanValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns BooleanValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns BooleanValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns BooleanValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns BooleanValue
	 *     ArithmeticExpression returns BooleanValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns BooleanValue
	 *     BaseExpression returns BooleanValue
	 *     BooleanValue returns BooleanValue
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BooleanValue(ISerializationContext context, BooleanValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns CNLRule
	 *     CNLRule returns CNLRule
	 *
	 * Constraint:
	 *     (name=ID? astRoot=LogicalExpression message=STRING?)
	 */
	protected void sequence_CNLRule(ISerializationContext context, CNLRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EqualityExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns EqualityExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns EqualityExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns EqualityExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns EqualityExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns EqualityExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns EqualityExpression
	 *     ComparisonExpression returns EqualityExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns EqualityExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns EqualityExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns EqualityExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns EqualityExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns EqualityExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns EqualityExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns EqualityExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns EqualityExpression
	 *
	 * Constraint:
	 *     (
	 *         (lhs=ComparisonExpression_EqualityExpression_1_1_0_0 rhs=ExistanceValue) | 
	 *         (lhs=ComparisonExpression_EqualityExpression_1_1_2_0 rhs=ArithmeticExpression)
	 *     )
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns GTEExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns GTEExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns GTEExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns GTEExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns GTEExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns GTEExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns GTEExpression
	 *     ComparisonExpression returns GTEExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns GTEExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns GTEExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns GTEExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns GTEExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns GTEExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns GTEExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns GTEExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns GTEExpression
	 *
	 * Constraint:
	 *     (lhs=ComparisonExpression_GTEExpression_1_1_6_0 rhs=ArithmeticExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, GTEExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getGTEExpressionLhsAction_1_1_6_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRhsArithmeticExpressionParserRuleCall_1_1_6_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns GreaterThanExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns GreaterThanExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns GreaterThanExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns GreaterThanExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns GreaterThanExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns GreaterThanExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns GreaterThanExpression
	 *     ComparisonExpression returns GreaterThanExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns GreaterThanExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns GreaterThanExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns GreaterThanExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns GreaterThanExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns GreaterThanExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns GreaterThanExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns GreaterThanExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns GreaterThanExpression
	 *
	 * Constraint:
	 *     (lhs=ComparisonExpression_GreaterThanExpression_1_1_4_0 rhs=ArithmeticExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, GreaterThanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getGreaterThanExpressionLhsAction_1_1_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRhsArithmeticExpressionParserRuleCall_1_1_4_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LTEExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns LTEExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns LTEExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns LTEExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns LTEExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns LTEExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns LTEExpression
	 *     ComparisonExpression returns LTEExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns LTEExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns LTEExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns LTEExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns LTEExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns LTEExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns LTEExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns LTEExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns LTEExpression
	 *
	 * Constraint:
	 *     (lhs=ComparisonExpression_LTEExpression_1_1_7_0 rhs=ArithmeticExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, LTEExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getLTEExpressionLhsAction_1_1_7_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRhsArithmeticExpressionParserRuleCall_1_1_7_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LessThanExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns LessThanExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns LessThanExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns LessThanExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns LessThanExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns LessThanExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns LessThanExpression
	 *     ComparisonExpression returns LessThanExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns LessThanExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns LessThanExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns LessThanExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns LessThanExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns LessThanExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns LessThanExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns LessThanExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns LessThanExpression
	 *
	 * Constraint:
	 *     (lhs=ComparisonExpression_LessThanExpression_1_1_5_0 rhs=ArithmeticExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, LessThanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.COMPARISON_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getLessThanExpressionLhsAction_1_1_5_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRhsArithmeticExpressionParserRuleCall_1_1_5_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NegatedEqualityExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns NegatedEqualityExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns NegatedEqualityExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns NegatedEqualityExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns NegatedEqualityExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns NegatedEqualityExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns NegatedEqualityExpression
	 *     ComparisonExpression returns NegatedEqualityExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns NegatedEqualityExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns NegatedEqualityExpression
	 *
	 * Constraint:
	 *     (
	 *         (lhs=ComparisonExpression_NegatedEqualityExpression_1_1_1_0 rhs=EmptyValue) | 
	 *         (lhs=ComparisonExpression_NegatedEqualityExpression_1_1_3_0 rhs=ArithmeticExpression)
	 *     )
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, NegatedEqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstrainedNaturalLanguageRules returns ConstrainedNaturalLanguageRules
	 *
	 * Constraint:
	 *     (((rules+=ScopedRules | rules+=MatchScopedRule)+ metadata+=MetaData+) | metadata+=MetaData+)?
	 */
	protected void sequence_ConstrainedNaturalLanguageRules(ISerializationContext context, ConstrainedNaturalLanguageRules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns AfterDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns AfterDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns AfterDateExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns AfterDateExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns AfterDateExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns AfterDateExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns AfterDateExpression
	 *     ComparisonExpression returns AfterDateExpression
	 *     DateExpression returns AfterDateExpression
	 *
	 * Constraint:
	 *     (lhs=BaseExpression rhs=BaseExpression)
	 */
	protected void sequence_DateExpression(ISerializationContext context, AfterDateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateExpressionAccess().getLhsBaseExpressionParserRuleCall_1_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getDateExpressionAccess().getRhsBaseExpressionParserRuleCall_1_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns BeforeDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns BeforeDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns BeforeDateExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns BeforeDateExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns BeforeDateExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns BeforeDateExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns BeforeDateExpression
	 *     ComparisonExpression returns BeforeDateExpression
	 *     DateExpression returns BeforeDateExpression
	 *
	 * Constraint:
	 *     (lhs=BaseExpression rhs=BaseExpression)
	 */
	protected void sequence_DateExpression(ISerializationContext context, BeforeDateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateExpressionAccess().getLhsBaseExpressionParserRuleCall_0_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getDateExpressionAccess().getRhsBaseExpressionParserRuleCall_0_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns OnorafterDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns OnorafterDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns OnorafterDateExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns OnorafterDateExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns OnorafterDateExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns OnorafterDateExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns OnorafterDateExpression
	 *     ComparisonExpression returns OnorafterDateExpression
	 *     DateExpression returns OnorafterDateExpression
	 *
	 * Constraint:
	 *     (lhs=BaseExpression rhs=BaseExpression)
	 */
	protected void sequence_DateExpression(ISerializationContext context, OnorafterDateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateExpressionAccess().getLhsBaseExpressionParserRuleCall_3_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getDateExpressionAccess().getRhsBaseExpressionParserRuleCall_3_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns OnorbeforeDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns OnorbeforeDateExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns OnorbeforeDateExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns OnorbeforeDateExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns OnorbeforeDateExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns OnorbeforeDateExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns OnorbeforeDateExpression
	 *     ComparisonExpression returns OnorbeforeDateExpression
	 *     DateExpression returns OnorbeforeDateExpression
	 *
	 * Constraint:
	 *     (lhs=BaseExpression rhs=BaseExpression)
	 */
	protected void sequence_DateExpression(ISerializationContext context, OnorbeforeDateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateExpressionAccess().getLhsBaseExpressionParserRuleCall_2_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getDateExpressionAccess().getRhsBaseExpressionParserRuleCall_2_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns DateValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns DateValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns DateValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns DateValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns DateValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns DateValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns DateValue
	 *     ComparisonExpression returns DateValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns DateValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns DateValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns DateValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns DateValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns DateValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns DateValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns DateValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns DateValue
	 *     ArithmeticExpression returns DateValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns DateValue
	 *     BaseExpression returns DateValue
	 *     DateValue returns DateValue
	 *
	 * Constraint:
	 *     value=DATE
	 */
	protected void sequence_DateValue(ISerializationContext context, DateValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DATE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DATE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDateValueAccess().getValueDATETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns DecimalValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns DecimalValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns DecimalValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns DecimalValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns DecimalValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns DecimalValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns DecimalValue
	 *     ComparisonExpression returns DecimalValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns DecimalValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns DecimalValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns DecimalValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns DecimalValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns DecimalValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns DecimalValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns DecimalValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns DecimalValue
	 *     ArithmeticExpression returns DecimalValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns DecimalValue
	 *     BaseExpression returns DecimalValue
	 *     DecimalValue returns DecimalValue
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalValue(ISerializationContext context, DecimalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.DECIMAL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.DECIMAL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalValueAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns EOLExpressionRule
	 *     GPLRule returns EOLExpressionRule
	 *     EOLExpressionRule returns EOLExpressionRule
	 *
	 * Constraint:
	 *     (name=ID? code=STRING message=STRING?)
	 */
	protected void sequence_EOLExpressionRule(ISerializationContext context, EOLExpressionRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementScope returns ElementScope
	 *
	 * Constraint:
	 *     type=[Type|ID]
	 */
	protected void sequence_ElementScope(ISerializationContext context, ElementScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.ELEMENT_SCOPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.ELEMENT_SCOPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementScopeAccess().getTypeTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(CnlPackage.Literals.ELEMENT_SCOPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EmptyValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns EmptyValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns EmptyValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns EmptyValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns EmptyValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns EmptyValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns EmptyValue
	 *     ComparisonExpression returns EmptyValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns EmptyValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns EmptyValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns EmptyValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns EmptyValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns EmptyValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns EmptyValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns EmptyValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns EmptyValue
	 *     ArithmeticExpression returns EmptyValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns EmptyValue
	 *     BaseExpression returns EmptyValue
	 *     EmptyValue returns EmptyValue
	 *
	 * Constraint:
	 *     {EmptyValue}
	 */
	protected void sequence_EmptyValue(ISerializationContext context, EmptyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EnumTypeExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns EnumTypeExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns EnumTypeExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns EnumTypeExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns EnumTypeExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns EnumTypeExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns EnumTypeExpression
	 *     ComparisonExpression returns EnumTypeExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns EnumTypeExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns EnumTypeExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns EnumTypeExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns EnumTypeExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns EnumTypeExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns EnumTypeExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns EnumTypeExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns EnumTypeExpression
	 *     ArithmeticExpression returns EnumTypeExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns EnumTypeExpression
	 *     BaseExpression returns EnumTypeExpression
	 *     TypeExpression returns EnumTypeExpression
	 *     EnumTypeExpression returns EnumTypeExpression
	 *
	 * Constraint:
	 *     (feature=FeatureValue type=[Enum|ID])
	 */
	protected void sequence_EnumTypeExpression(ISerializationContext context, EnumTypeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.TYPE_EXPRESSION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.TYPE_EXPRESSION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.ENUM_TYPE_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.ENUM_TYPE_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumTypeExpressionAccess().getFeatureFeatureValueParserRuleCall_0_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getEnumTypeExpressionAccess().getTypeEnumIDTerminalRuleCall_2_0_1(), semanticObject.eGet(CnlPackage.Literals.ENUM_TYPE_EXPRESSION__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns EnumValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns EnumValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns EnumValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns EnumValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns EnumValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns EnumValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns EnumValue
	 *     ComparisonExpression returns EnumValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns EnumValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns EnumValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns EnumValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns EnumValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns EnumValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns EnumValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns EnumValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns EnumValue
	 *     ArithmeticExpression returns EnumValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns EnumValue
	 *     BaseExpression returns EnumValue
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     ((enumeration=[Enum|ID] value=STRING) | (enumeration=[Enum|ID] value=STRING))
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Enum(ISerializationContext context, cnl.Enum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.META_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.META_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaData returns Enumerations
	 *     Enumerations returns Enumerations
	 *
	 * Constraint:
	 *     (legalValues+=Enum legalValues+=Enum*)
	 */
	protected void sequence_Enumerations(ISerializationContext context, Enumerations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExistanceValue returns ExistanceValue
	 *
	 * Constraint:
	 *     {ExistanceValue}
	 */
	protected void sequence_ExistanceValue(ISerializationContext context, ExistanceValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureValue returns FeatureValue
	 *
	 * Constraint:
	 *     feature=[Feature|ID]
	 */
	protected void sequence_FeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureValueAccess().getFeatureFeatureIDTerminalRuleCall_1_0_1(), semanticObject.eGet(CnlPackage.Literals.FEATURE_VALUE__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns FeatureValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns FeatureValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns FeatureValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns FeatureValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns FeatureValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns FeatureValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns FeatureValue
	 *     ComparisonExpression returns FeatureValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns FeatureValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns FeatureValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns FeatureValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns FeatureValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns FeatureValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns FeatureValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns FeatureValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns FeatureValue
	 *     ArithmeticExpression returns FeatureValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns FeatureValue
	 *     BaseExpression returns FeatureValue
	 *
	 * Constraint:
	 *     (feature=[Feature|ID] | (feature=[Feature|ID] variableName=ID) | (feature=[Feature|ID] scope=ElementScope))
	 */
	protected void sequence_FeatureValue_UnscopedFeatureValue_VariableFeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.META_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.META_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns IntegerValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns IntegerValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns IntegerValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns IntegerValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns IntegerValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns IntegerValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns IntegerValue
	 *     ComparisonExpression returns IntegerValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns IntegerValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns IntegerValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns IntegerValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns IntegerValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns IntegerValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns IntegerValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns IntegerValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns IntegerValue
	 *     ArithmeticExpression returns IntegerValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns IntegerValue
	 *     BaseExpression returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.INTEGER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerValueAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns AndExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns AndExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns AndExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns AndExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns AndExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns AndExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns AndExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression_AndExpression_0_1_4_0 rhs=ComparisonExpression)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getAndExpressionLhsAction_0_1_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRhsComparisonExpressionParserRuleCall_0_1_4_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns ImpliesExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns ImpliesExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns ImpliesExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns ImpliesExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns ImpliesExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns ImpliesExpression
	 *
	 * Constraint:
	 *     (
	 *         (lhs=LogicalExpression_ImpliesExpression_0_1_0_0 rhs=ComparisonExpression) | 
	 *         (rhs=LogicalExpression_ImpliesExpression_0_1_1_0 lhs=ComparisonExpression)
	 *     )
	 */
	protected void sequence_LogicalExpression_AndExpression_0_1_4_0_IfandonlyifExpression_0_1_5_0_ImpliesExpression_0_1_0_0_ImpliesExpression_0_1_1_0_OrExpression_0_1_2_0_XorExpression_0_1_3_0(ISerializationContext context, ImpliesExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns XorExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns XorExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns XorExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns XorExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns XorExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns XorExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression_XorExpression_0_1_3_0 rhs=ComparisonExpression)
	 */
	protected void sequence_LogicalExpression_AndExpression_0_1_4_0_IfandonlyifExpression_0_1_5_0_ImpliesExpression_0_1_0_0_ImpliesExpression_0_1_1_0_OrExpression_0_1_2_0_XorExpression_0_1_3_0(ISerializationContext context, XorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getXorExpressionLhsAction_0_1_3_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRhsComparisonExpressionParserRuleCall_0_1_3_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns IfandonlyifExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns IfandonlyifExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns IfandonlyifExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns IfandonlyifExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns IfandonlyifExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns IfandonlyifExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns IfandonlyifExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression_IfandonlyifExpression_0_1_5_0 rhs=ComparisonExpression)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, IfandonlyifExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getIfandonlyifExpressionLhsAction_0_1_5_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRhsComparisonExpressionParserRuleCall_0_1_5_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns ImpliesExpression
	 *
	 * Constraint:
	 *     (
	 *         (lhs=LogicalExpression_ImpliesExpression_0_1_0_0 rhs=ComparisonExpression) | 
	 *         (rhs=LogicalExpression_ImpliesExpression_0_1_1_0 lhs=ComparisonExpression) | 
	 *         (lhs=LogicalExpression rhs=LogicalExpression)
	 *     )
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, ImpliesExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns OrExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns OrExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns OrExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns OrExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns OrExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns OrExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns OrExpression
	 *
	 * Constraint:
	 *     (lhs=LogicalExpression_OrExpression_0_1_2_0 rhs=ComparisonExpression)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.LOGICAL_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getOrExpressionLhsAction_0_1_2_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRhsComparisonExpressionParserRuleCall_0_1_2_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns XorExpression
	 *
	 * Constraint:
	 *     ((lhs=LogicalExpression_XorExpression_0_1_3_0 rhs=ComparisonExpression) | (lhs=LogicalExpression rhs=LogicalExpression))
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, XorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchScopedRule returns MatchScopedRule
	 *
	 * Constraint:
	 *     (matches+=MatchingRule+ rule=Rule)
	 */
	protected void sequence_MatchScopedRule(ISerializationContext context, MatchScopedRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchingRule returns MatchingRule
	 *
	 * Constraint:
	 *     ((variableName=ID scope=ElementScope astRoot=LogicalExpression) | (scope=ElementScope astRoot=LogicalExpression))
	 */
	protected void sequence_MatchingRule(ISerializationContext context, MatchingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NumericAverage
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns NumericAverage
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns NumericAverage
	 *     LogicalExpression.OrExpression_0_1_2_0 returns NumericAverage
	 *     LogicalExpression.XorExpression_0_1_3_0 returns NumericAverage
	 *     LogicalExpression.AndExpression_0_1_4_0 returns NumericAverage
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns NumericAverage
	 *     ComparisonExpression returns NumericAverage
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns NumericAverage
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns NumericAverage
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns NumericAverage
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns NumericAverage
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns NumericAverage
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns NumericAverage
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns NumericAverage
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns NumericAverage
	 *     ArithmeticExpression returns NumericAverage
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NumericAverage
	 *     BaseExpression returns NumericAverage
	 *     NumericAggregation returns NumericAverage
	 *     NumericAverage returns NumericAverage
	 *
	 * Constraint:
	 *     (feature=FeatureValue | feature=UnscopedFeatureValue | feature=VariableFeatureValue)
	 */
	protected void sequence_NumericAverage(ISerializationContext context, NumericAverage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NumericMaximum
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns NumericMaximum
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns NumericMaximum
	 *     LogicalExpression.OrExpression_0_1_2_0 returns NumericMaximum
	 *     LogicalExpression.XorExpression_0_1_3_0 returns NumericMaximum
	 *     LogicalExpression.AndExpression_0_1_4_0 returns NumericMaximum
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns NumericMaximum
	 *     ComparisonExpression returns NumericMaximum
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns NumericMaximum
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns NumericMaximum
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns NumericMaximum
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns NumericMaximum
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns NumericMaximum
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns NumericMaximum
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns NumericMaximum
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns NumericMaximum
	 *     ArithmeticExpression returns NumericMaximum
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NumericMaximum
	 *     BaseExpression returns NumericMaximum
	 *     NumericAggregation returns NumericMaximum
	 *     NumericMaximum returns NumericMaximum
	 *
	 * Constraint:
	 *     (feature=FeatureValue | feature=UnscopedFeatureValue | feature=VariableFeatureValue)
	 */
	protected void sequence_NumericMaximum(ISerializationContext context, NumericMaximum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NumericMinimum
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns NumericMinimum
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns NumericMinimum
	 *     LogicalExpression.OrExpression_0_1_2_0 returns NumericMinimum
	 *     LogicalExpression.XorExpression_0_1_3_0 returns NumericMinimum
	 *     LogicalExpression.AndExpression_0_1_4_0 returns NumericMinimum
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns NumericMinimum
	 *     ComparisonExpression returns NumericMinimum
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns NumericMinimum
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns NumericMinimum
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns NumericMinimum
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns NumericMinimum
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns NumericMinimum
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns NumericMinimum
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns NumericMinimum
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns NumericMinimum
	 *     ArithmeticExpression returns NumericMinimum
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NumericMinimum
	 *     BaseExpression returns NumericMinimum
	 *     NumericAggregation returns NumericMinimum
	 *     NumericMinimum returns NumericMinimum
	 *
	 * Constraint:
	 *     (feature=FeatureValue | feature=UnscopedFeatureValue | feature=VariableFeatureValue)
	 */
	protected void sequence_NumericMinimum(ISerializationContext context, NumericMinimum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns NumericSummation
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns NumericSummation
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns NumericSummation
	 *     LogicalExpression.OrExpression_0_1_2_0 returns NumericSummation
	 *     LogicalExpression.XorExpression_0_1_3_0 returns NumericSummation
	 *     LogicalExpression.AndExpression_0_1_4_0 returns NumericSummation
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns NumericSummation
	 *     ComparisonExpression returns NumericSummation
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns NumericSummation
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns NumericSummation
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns NumericSummation
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns NumericSummation
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns NumericSummation
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns NumericSummation
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns NumericSummation
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns NumericSummation
	 *     ArithmeticExpression returns NumericSummation
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NumericSummation
	 *     BaseExpression returns NumericSummation
	 *     NumericAggregation returns NumericSummation
	 *     NumericSummation returns NumericSummation
	 *
	 * Constraint:
	 *     (feature=FeatureValue | feature=UnscopedFeatureValue | feature=VariableFeatureValue)
	 */
	protected void sequence_NumericSummation(ISerializationContext context, NumericSummation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns PrimitiveTypeExpression
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns PrimitiveTypeExpression
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns PrimitiveTypeExpression
	 *     LogicalExpression.OrExpression_0_1_2_0 returns PrimitiveTypeExpression
	 *     LogicalExpression.XorExpression_0_1_3_0 returns PrimitiveTypeExpression
	 *     LogicalExpression.AndExpression_0_1_4_0 returns PrimitiveTypeExpression
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression returns PrimitiveTypeExpression
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns PrimitiveTypeExpression
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns PrimitiveTypeExpression
	 *     ArithmeticExpression returns PrimitiveTypeExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns PrimitiveTypeExpression
	 *     BaseExpression returns PrimitiveTypeExpression
	 *     TypeExpression returns PrimitiveTypeExpression
	 *     PrimitiveTypeExpression returns PrimitiveTypeExpression
	 *
	 * Constraint:
	 *     (feature=FeatureValue type=PrimitiveTypes)
	 */
	protected void sequence_PrimitiveTypeExpression(ISerializationContext context, PrimitiveTypeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.TYPE_EXPRESSION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.TYPE_EXPRESSION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.PRIMITIVE_TYPE_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.PRIMITIVE_TYPE_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveTypeExpressionAccess().getFeatureFeatureValueParserRuleCall_0_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getPrimitiveTypeExpressionAccess().getTypePrimitiveTypesEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScopedRules returns ScopedRules
	 *
	 * Constraint:
	 *     ((scope=ElementScope | scope=ElementScope) rules+=Rule+)
	 */
	protected void sequence_ScopedRules(ISerializationContext context, ScopedRules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns StringValue
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns StringValue
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns StringValue
	 *     LogicalExpression.OrExpression_0_1_2_0 returns StringValue
	 *     LogicalExpression.XorExpression_0_1_3_0 returns StringValue
	 *     LogicalExpression.AndExpression_0_1_4_0 returns StringValue
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns StringValue
	 *     ComparisonExpression returns StringValue
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns StringValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns StringValue
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns StringValue
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns StringValue
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns StringValue
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns StringValue
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns StringValue
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns StringValue
	 *     ArithmeticExpression returns StringValue
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns StringValue
	 *     BaseExpression returns StringValue
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeValue returns Type
	 *
	 * Constraint:
	 *     (name=ID (features+=Feature features+=Feature*)?)
	 */
	protected void sequence_TypeValue(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaData returns Types
	 *     Types returns Types
	 *
	 * Constraint:
	 *     (legalValues+=TypeValue legalValues+=TypeValue*)
	 */
	protected void sequence_Types(ISerializationContext context, Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns UniquenessCheck
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns UniquenessCheck
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns UniquenessCheck
	 *     LogicalExpression.OrExpression_0_1_2_0 returns UniquenessCheck
	 *     LogicalExpression.XorExpression_0_1_3_0 returns UniquenessCheck
	 *     LogicalExpression.AndExpression_0_1_4_0 returns UniquenessCheck
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns UniquenessCheck
	 *     ComparisonExpression returns UniquenessCheck
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns UniquenessCheck
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns UniquenessCheck
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns UniquenessCheck
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns UniquenessCheck
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns UniquenessCheck
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns UniquenessCheck
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns UniquenessCheck
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns UniquenessCheck
	 *     ArithmeticExpression returns UniquenessCheck
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns UniquenessCheck
	 *     BaseExpression returns UniquenessCheck
	 *     UniquenessCheck returns UniquenessCheck
	 *
	 * Constraint:
	 *     (features+=FeatureValue features+=FeatureValue*)
	 */
	protected void sequence_UniquenessCheck(ISerializationContext context, UniquenessCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnscopedFeatureValue returns FeatureValue
	 *
	 * Constraint:
	 *     (feature=[Feature|ID] scope=ElementScope)
	 */
	protected void sequence_UnscopedFeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.FEATURE_VALUE__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.FEATURE_VALUE__SCOPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnscopedFeatureValueAccess().getFeatureFeatureIDTerminalRuleCall_0_0_1(), semanticObject.eGet(CnlPackage.Literals.FEATURE_VALUE__FEATURE, false));
		feeder.accept(grammarAccess.getUnscopedFeatureValueAccess().getScopeElementScopeParserRuleCall_2_0(), semanticObject.getScope());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns ValueContainment
	 *     LogicalExpression.ImpliesExpression_0_1_0_0 returns ValueContainment
	 *     LogicalExpression.ImpliesExpression_0_1_1_0 returns ValueContainment
	 *     LogicalExpression.OrExpression_0_1_2_0 returns ValueContainment
	 *     LogicalExpression.XorExpression_0_1_3_0 returns ValueContainment
	 *     LogicalExpression.AndExpression_0_1_4_0 returns ValueContainment
	 *     LogicalExpression.IfandonlyifExpression_0_1_5_0 returns ValueContainment
	 *     ComparisonExpression returns ValueContainment
	 *     ComparisonExpression.EqualityExpression_1_1_0_0 returns ValueContainment
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_1_0 returns ValueContainment
	 *     ComparisonExpression.EqualityExpression_1_1_2_0 returns ValueContainment
	 *     ComparisonExpression.NegatedEqualityExpression_1_1_3_0 returns ValueContainment
	 *     ComparisonExpression.GreaterThanExpression_1_1_4_0 returns ValueContainment
	 *     ComparisonExpression.LessThanExpression_1_1_5_0 returns ValueContainment
	 *     ComparisonExpression.GTEExpression_1_1_6_0 returns ValueContainment
	 *     ComparisonExpression.LTEExpression_1_1_7_0 returns ValueContainment
	 *     ArithmeticExpression returns ValueContainment
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ValueContainment
	 *     BaseExpression returns ValueContainment
	 *     ValueContainment returns ValueContainment
	 *
	 * Constraint:
	 *     ((feature=FeatureValue | feature=UnscopedFeatureValue | feature=VariableFeatureValue) collection+=BaseExpression collection+=BaseExpression*)
	 */
	protected void sequence_ValueContainment(ISerializationContext context, ValueContainment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableFeatureValue returns FeatureValue
	 *
	 * Constraint:
	 *     (feature=[Feature|ID] variableName=ID)
	 */
	protected void sequence_VariableFeatureValue(ISerializationContext context, FeatureValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.FEATURE_VALUE__FEATURE));
			if (transientValues.isValueTransient(semanticObject, CnlPackage.Literals.FEATURE_VALUE__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CnlPackage.Literals.FEATURE_VALUE__VARIABLE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableFeatureValueAccess().getFeatureFeatureIDTerminalRuleCall_0_0_1(), semanticObject.eGet(CnlPackage.Literals.FEATURE_VALUE__FEATURE, false));
		feeder.accept(grammarAccess.getVariableFeatureValueAccess().getVariableNameIDTerminalRuleCall_2_0(), semanticObject.getVariableName());
		feeder.finish();
	}
	
	
}
